{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport AbstractFilterBuilder from './abstract';\nimport { categoriesListData, categoriesTreeData, prepareCategory } from '../database/categories';\n\nvar CategoryFilterBuilder = /*#__PURE__*/function (_AbstractFilterBuilde) {\n  _inherits(CategoryFilterBuilder, _AbstractFilterBuilde);\n\n  var _super = _createSuper(CategoryFilterBuilder);\n\n  function CategoryFilterBuilder() {\n    var _this;\n\n    _classCallCheck(this, CategoryFilterBuilder);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"value\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"items\", []);\n\n    return _this;\n  }\n\n  _createClass(CategoryFilterBuilder, [{\n    key: \"test\",\n    value: function test() {\n      if (this.value === null) {\n        return true;\n      } // return product.categories.reduce((acc, category) => (\n      //     acc || category.slug === this.value\n      // ), false);\n\n\n      return true;\n    }\n  }, {\n    key: \"makeItems\",\n    value: function makeItems(products, value) {\n      this.value = value || null;\n      var category = categoriesListData.find(function (x) {\n        return x.slug === value;\n      }); // const categoryHasProductsFn = (x) => categoryHasProducts(x, productsData);\n\n      var categoryHasProductsFn = function categoryHasProductsFn() {\n        return true;\n      };\n\n      if (category) {\n        this.items = [prepareCategory(category, 1)].map(function (x) {\n          return _objectSpread(_objectSpread({}, x), {}, {\n            children: x.children === undefined ? [] : x.children.filter(categoryHasProductsFn)\n          });\n        });\n      } else {\n        this.items = categoriesTreeData.map(function (x) {\n          return prepareCategory(x);\n        }).filter(categoryHasProductsFn);\n      }\n    } // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"calc\",\n    value: function calc() {}\n  }, {\n    key: \"build\",\n    value: function build() {\n      return {\n        type: 'category',\n        slug: this.slug,\n        name: this.name,\n        items: this.items,\n        value: this.value\n      };\n    }\n  }]);\n\n  return CategoryFilterBuilder;\n}(AbstractFilterBuilder);\n\nexport { CategoryFilterBuilder as default };","map":{"version":3,"sources":["D:/xampp/htdocs/neo.co.th/nextapp/src/fake-server/filters/category.ts"],"names":["AbstractFilterBuilder","categoriesListData","categoriesTreeData","prepareCategory","CategoryFilterBuilder","value","products","category","find","x","slug","categoryHasProductsFn","items","map","children","undefined","filter","type","name"],"mappings":";;;;;;;;;;;;;;;;AAAA,OAAOA,qBAAP,MAAkC,YAAlC;AAIA,SACIC,kBADJ,EAEIC,kBAFJ,EAGIC,eAHJ,QAIO,wBAJP;;IAMqBC,qB;;;;;;;;;;;;;;;;4DACa,I;;4DAEL,E;;;;;;;2BAElB;AACH,UAAI,KAAKC,KAAL,KAAe,IAAnB,EAAyB;AACrB,eAAO,IAAP;AACH,OAHE,CAKH;AACA;AACA;;;AAEA,aAAO,IAAP;AACH;;;8BAESC,Q,EAAsBD,K,EAAsB;AAClD,WAAKA,KAAL,GAAaA,KAAK,IAAI,IAAtB;AAEA,UAAME,QAAQ,GAAGN,kBAAkB,CAACO,IAAnB,CAAwB,UAACC,CAAD;AAAA,eAAOA,CAAC,CAACC,IAAF,KAAWL,KAAlB;AAAA,OAAxB,CAAjB,CAHkD,CAIlD;;AACA,UAAMM,qBAAqB,GAAG,SAAxBA,qBAAwB;AAAA,eAAM,IAAN;AAAA,OAA9B;;AAEA,UAAIJ,QAAJ,EAAc;AACV,aAAKK,KAAL,GAAa,CAACT,eAAe,CAACI,QAAD,EAAW,CAAX,CAAhB,EAA+BM,GAA/B,CAAmC,UAACJ,CAAD;AAAA,iDACzCA,CADyC;AAE5CK,YAAAA,QAAQ,EAAEL,CAAC,CAACK,QAAF,KAAeC,SAAf,GAA2B,EAA3B,GAAgCN,CAAC,CAACK,QAAF,CAAWE,MAAX,CAAkBL,qBAAlB;AAFE;AAAA,SAAnC,CAAb;AAIH,OALD,MAKO;AACH,aAAKC,KAAL,GAAaV,kBAAkB,CAC1BW,GADQ,CACJ,UAACJ,CAAD;AAAA,iBAAON,eAAe,CAACM,CAAD,CAAtB;AAAA,SADI,EAERO,MAFQ,CAEDL,qBAFC,CAAb;AAGH;AACJ,K,CAED;;;;2BACa,CAAE;;;4BAEU;AACrB,aAAO;AACHM,QAAAA,IAAI,EAAE,UADH;AAEHP,QAAAA,IAAI,EAAE,KAAKA,IAFR;AAGHQ,QAAAA,IAAI,EAAE,KAAKA,IAHR;AAIHN,QAAAA,KAAK,EAAE,KAAKA,KAJT;AAKHP,QAAAA,KAAK,EAAE,KAAKA;AALT,OAAP;AAOH;;;;EA/C8CL,qB;;SAA9BI,qB","sourcesContent":["import AbstractFilterBuilder from './abstract';\nimport { ICategoryFilter, ICategoryFilterValue } from '../../interfaces/filter';\nimport { IProduct } from '../../interfaces/product';\nimport { IShopCategory } from '../../interfaces/category';\nimport {\n    categoriesListData,\n    categoriesTreeData,\n    prepareCategory,\n} from '../database/categories';\n\nexport default class CategoryFilterBuilder extends AbstractFilterBuilder<ICategoryFilter> {\n    value: ICategoryFilterValue = null;\n\n    items: IShopCategory[] = [];\n\n    test() {\n        if (this.value === null) {\n            return true;\n        }\n\n        // return product.categories.reduce((acc, category) => (\n        //     acc || category.slug === this.value\n        // ), false);\n\n        return true;\n    }\n\n    makeItems(products: IProduct[], value?: string): void {\n        this.value = value || null;\n\n        const category = categoriesListData.find((x) => x.slug === value);\n        // const categoryHasProductsFn = (x) => categoryHasProducts(x, productsData);\n        const categoryHasProductsFn = () => true;\n\n        if (category) {\n            this.items = [prepareCategory(category, 1)].map((x) => ({\n                ...x,\n                children: x.children === undefined ? [] : x.children.filter(categoryHasProductsFn),\n            }));\n        } else {\n            this.items = categoriesTreeData\n                .map((x) => prepareCategory(x))\n                .filter(categoryHasProductsFn);\n        }\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    calc(): void {}\n\n    build(): ICategoryFilter {\n        return {\n            type: 'category',\n            slug: this.slug,\n            name: this.name,\n            items: this.items,\n            value: this.value,\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}