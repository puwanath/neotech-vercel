{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport AbstractFilterBuilder from './abstract';\nimport { categoriesListData, categoriesTreeData, prepareCategory } from '../database/categories';\nexport default class CategoryFilterBuilder extends AbstractFilterBuilder {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"value\", null);\n\n    _defineProperty(this, \"items\", []);\n  }\n\n  test() {\n    if (this.value === null) {\n      return true;\n    } // return product.categories.reduce((acc, category) => (\n    //     acc || category.slug === this.value\n    // ), false);\n\n\n    return true;\n  }\n\n  makeItems(products, value) {\n    this.value = value || null;\n    const category = categoriesListData.find(x => x.cat_slug === value); // const categoryHasProductsFn = (x) => categoryHasProducts(x, productsData);\n\n    const categoryHasProductsFn = () => true;\n\n    if (category) {\n      this.items = [prepareCategory(category, 1)].map(x => _objectSpread(_objectSpread({}, x), {}, {\n        children: x.children === undefined ? [] : x.children.filter(categoryHasProductsFn)\n      }));\n    } else {\n      this.items = categoriesTreeData.map(x => prepareCategory(x)).filter(categoryHasProductsFn);\n    }\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  calc() {}\n\n  build() {\n    return {\n      type: 'category',\n      slug: this.slug,\n      name: this.name,\n      items: this.items,\n      value: this.value\n    };\n  }\n\n}","map":{"version":3,"sources":["D:/xampp/htdocs/neo.co.th/nextapp/src/fake-server/filters/category.ts"],"names":["AbstractFilterBuilder","categoriesListData","categoriesTreeData","prepareCategory","CategoryFilterBuilder","test","value","makeItems","products","category","find","x","cat_slug","categoryHasProductsFn","items","map","children","undefined","filter","calc","build","type","slug","name"],"mappings":";;;;;;AAAA,OAAOA,qBAAP,MAAkC,YAAlC;AAIA,SACIC,kBADJ,EAEIC,kBAFJ,EAGIC,eAHJ,QAIO,wBAJP;AAMA,eAAe,MAAMC,qBAAN,SAAoCJ,qBAApC,CAA2E;AAAA;AAAA;;AAAA,mCACxD,IADwD;;AAAA,mCAG7D,EAH6D;AAAA;;AAKtFK,EAAAA,IAAI,GAAG;AACH,QAAI,KAAKC,KAAL,KAAe,IAAnB,EAAyB;AACrB,aAAO,IAAP;AACH,KAHE,CAKH;AACA;AACA;;;AAEA,WAAO,IAAP;AACH;;AAEDC,EAAAA,SAAS,CAACC,QAAD,EAAuBF,KAAvB,EAA6C;AAClD,SAAKA,KAAL,GAAaA,KAAK,IAAI,IAAtB;AAEA,UAAMG,QAAQ,GAAGR,kBAAkB,CAACS,IAAnB,CAAyBC,CAAD,IAAOA,CAAC,CAACC,QAAF,KAAeN,KAA9C,CAAjB,CAHkD,CAIlD;;AACA,UAAMO,qBAAqB,GAAG,MAAM,IAApC;;AAEA,QAAIJ,QAAJ,EAAc;AACV,WAAKK,KAAL,GAAa,CAACX,eAAe,CAACM,QAAD,EAAW,CAAX,CAAhB,EAA+BM,GAA/B,CAAoCJ,CAAD,oCACzCA,CADyC;AAE5CK,QAAAA,QAAQ,EAAEL,CAAC,CAACK,QAAF,KAAeC,SAAf,GAA2B,EAA3B,GAAgCN,CAAC,CAACK,QAAF,CAAWE,MAAX,CAAkBL,qBAAlB;AAFE,QAAnC,CAAb;AAIH,KALD,MAKO;AACH,WAAKC,KAAL,GAAaZ,kBAAkB,CAC1Ba,GADQ,CACHJ,CAAD,IAAOR,eAAe,CAACQ,CAAD,CADlB,EAERO,MAFQ,CAEDL,qBAFC,CAAb;AAGH;AACJ,GAlCqF,CAoCtF;;;AACAM,EAAAA,IAAI,GAAS,CAAE;;AAEfC,EAAAA,KAAK,GAAoB;AACrB,WAAO;AACHC,MAAAA,IAAI,EAAE,UADH;AAEHC,MAAAA,IAAI,EAAE,KAAKA,IAFR;AAGHC,MAAAA,IAAI,EAAE,KAAKA,IAHR;AAIHT,MAAAA,KAAK,EAAE,KAAKA,KAJT;AAKHR,MAAAA,KAAK,EAAE,KAAKA;AALT,KAAP;AAOH;;AA/CqF","sourcesContent":["import AbstractFilterBuilder from './abstract';\nimport { ICategoryFilter, ICategoryFilterValue } from '../../interfaces/filter';\nimport { IProduct } from '../../interfaces/product';\nimport { IShopCategory } from '../../interfaces/category';\nimport {\n    categoriesListData,\n    categoriesTreeData,\n    prepareCategory,\n} from '../database/categories';\n\nexport default class CategoryFilterBuilder extends AbstractFilterBuilder<ICategoryFilter> {\n    value: ICategoryFilterValue = null;\n\n    items: IShopCategory[] = [];\n\n    test() {\n        if (this.value === null) {\n            return true;\n        }\n\n        // return product.categories.reduce((acc, category) => (\n        //     acc || category.slug === this.value\n        // ), false);\n\n        return true;\n    }\n\n    makeItems(products: IProduct[], value?: string): void {\n        this.value = value || null;\n\n        const category = categoriesListData.find((x) => x.cat_slug === value);\n        // const categoryHasProductsFn = (x) => categoryHasProducts(x, productsData);\n        const categoryHasProductsFn = () => true;\n\n        if (category) {\n            this.items = [prepareCategory(category, 1)].map((x) => ({\n                ...x,\n                children: x.children === undefined ? [] : x.children.filter(categoryHasProductsFn),\n            }));\n        } else {\n            this.items = categoriesTreeData\n                .map((x) => prepareCategory(x))\n                .filter(categoryHasProductsFn);\n        }\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    calc(): void {}\n\n    build(): ICategoryFilter {\n        return {\n            type: 'category',\n            slug: this.slug,\n            name: this.name,\n            items: this.items,\n            value: this.value,\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}