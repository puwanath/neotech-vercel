{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nexport function useMedia(query) {\n  if (!false) {\n    return false;\n  }\n\n  const media = useMemo(() => window.matchMedia(query), [query]);\n  const {\n    0: state,\n    1: setState\n  } = useState(media.matches);\n  useEffect(() => {\n    const onChangeMedia = () => {\n      setState(media.matches);\n    };\n\n    if (media.addEventListener) {\n      media.addEventListener('change', onChangeMedia);\n    } else {\n      // noinspection JSDeprecatedSymbols\n      media.addListener(onChangeMedia);\n    }\n\n    return () => {\n      if (media.removeEventListener) {\n        media.removeEventListener('change', onChangeMedia);\n      } else {\n        // noinspection JSDeprecatedSymbols\n        media.removeListener(onChangeMedia);\n      }\n    };\n  }, [media]);\n  return state;\n}\nexport function useDeferredData(source, defaultData, initialData, deps = []) {\n  const {\n    0: state,\n    1: setState\n  } = useState(() => ({\n    isLoading: initialData === undefined,\n    data: initialData || defaultData\n  }));\n  const memoizedSource = useCallback(source, deps);\n  const skipNextRef = useRef(initialData !== undefined);\n  useEffect(() => {\n    if (skipNextRef.current) {\n      skipNextRef.current = false;\n      return () => {};\n    }\n\n    let canceled = false;\n    setState(curState => {\n      if (!curState.isLoading) {\n        return _objectSpread(_objectSpread({}, curState), {}, {\n          isLoading: true\n        });\n      }\n\n      return curState;\n    });\n    memoizedSource().then(data => {\n      if (canceled) {\n        return;\n      }\n\n      setState(() => ({\n        isLoading: false,\n        data\n      }));\n    });\n    return () => {\n      canceled = true;\n    };\n  }, [memoizedSource]);\n  return state;\n}\nexport function useProductTabs(tabs, productsSource, initialData) {\n  const {\n    0: currentTabId,\n    1: setCurrentTabId\n  } = useState(1);\n  const memoizedTabs = useMemo(() => tabs.map(tab => _objectSpread(_objectSpread({}, tab), {}, {\n    current: currentTabId === tab.id\n  })), [tabs, currentTabId]);\n  const currentTab = memoizedTabs.find(x => x.current);\n  const products = useDeferredData(() => currentTab ? productsSource(currentTab) : Promise.resolve([]), [], initialData, [currentTab]);\n  const handleTabChange = useCallback(tab => {\n    setCurrentTabId(tab.id);\n  }, [setCurrentTabId]);\n  return useMemo(() => _objectSpread({\n    tabs: memoizedTabs,\n    handleTabChange\n  }, products), [memoizedTabs, handleTabChange, products]);\n}\nexport function useProductColumns(columns) {\n  const products = useDeferredData(() => Promise.all(columns.map(column => column.source())), [], undefined, [columns]);\n  return useMemo(() => columns.map((column, index) => _objectSpread(_objectSpread({}, column), {}, {\n    products: products.data[index] || []\n  })), [columns, products]);\n}","map":{"version":3,"sources":["D:/xampp/htdocs/neo.co.th/nextapp/src/services/hooks.ts"],"names":["useCallback","useEffect","useMemo","useRef","useState","useMedia","query","media","window","matchMedia","state","setState","matches","onChangeMedia","addEventListener","addListener","removeEventListener","removeListener","useDeferredData","source","defaultData","initialData","deps","isLoading","undefined","data","memoizedSource","skipNextRef","current","canceled","curState","then","useProductTabs","tabs","productsSource","currentTabId","setCurrentTabId","memoizedTabs","map","tab","id","currentTab","find","x","products","Promise","resolve","handleTabChange","useProductColumns","columns","all","column","index"],"mappings":"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","sourcesContent":["import {\n    useCallback,\n    useEffect,\n    useMemo, useRef,\n    useState,\n} from 'react';\nimport { IProduct } from '../interfaces/product';\n\nexport function useMedia(query: string) {\n    if (!process.browser) {\n        return false;\n    }\n\n    const media = useMemo(() => window.matchMedia(query), [query]);\n    const [state, setState] = useState(media.matches);\n\n    useEffect(() => {\n        const onChangeMedia = () => {\n            setState(media.matches);\n        };\n\n        if (media.addEventListener) {\n            media.addEventListener('change', onChangeMedia);\n        } else {\n            // noinspection JSDeprecatedSymbols\n            media.addListener(onChangeMedia);\n        }\n\n        return () => {\n            if (media.removeEventListener) {\n                media.removeEventListener('change', onChangeMedia);\n            } else {\n                // noinspection JSDeprecatedSymbols\n                media.removeListener(onChangeMedia);\n            }\n        };\n    }, [media]);\n\n    return state;\n}\n\nexport type DeferredDataSource<T> = () => Promise<T>;\nexport type DeferredDataState<T> = { isLoading: boolean, data: T };\n\nexport function useDeferredData<T>(\n    source: DeferredDataSource<T>,\n    defaultData: T,\n    initialData?: T,\n    deps: any[] = [],\n): DeferredDataState<T> {\n    const [state, setState] = useState(() => ({\n        isLoading: initialData === undefined,\n        data: initialData || defaultData,\n    }));\n    const memoizedSource = useCallback(source, deps);\n    const skipNextRef = useRef(initialData !== undefined);\n\n    useEffect(() => {\n        if (skipNextRef.current) {\n            skipNextRef.current = false;\n\n            return () => {};\n        }\n\n        let canceled = false;\n\n        setState((curState) => {\n            if (!curState.isLoading) {\n                return { ...curState, isLoading: true };\n            }\n\n            return curState;\n        });\n\n        memoizedSource().then((data) => {\n            if (canceled) {\n                return;\n            }\n\n            setState(() => ({ isLoading: false, data }));\n        });\n\n        return () => {\n            canceled = true;\n        };\n    }, [memoizedSource]);\n\n    return state;\n}\n\nexport type ProductTab = { id: number; name: string };\nexport type WithCurrent<T> = T & {current: boolean};\nexport type ProductTabSource<T extends ProductTab> = (tab: T) => Promise<IProduct[]>;\nexport type ProductTabsState<T extends ProductTab> = {\n    tabs: WithCurrent<T>[];\n    handleTabChange: (tab: WithCurrent<T>) => void;\n} & DeferredDataState<IProduct[]>;\n\nexport function useProductTabs<T extends ProductTab>(\n    tabs: T[],\n    productsSource: ProductTabSource<T>,\n    initialData?: IProduct[],\n): ProductTabsState<T> {\n    const [currentTabId, setCurrentTabId] = useState(1);\n    const memoizedTabs = useMemo(() => (\n        tabs.map((tab) => ({\n            ...tab,\n            current: currentTabId === tab.id,\n        }))\n    ), [tabs, currentTabId]);\n    const currentTab = memoizedTabs.find((x) => x.current);\n    const products = useDeferredData(() => (\n        currentTab ? productsSource(currentTab) : Promise.resolve([])\n    ), [], initialData, [currentTab]);\n    const handleTabChange = useCallback((tab) => {\n        setCurrentTabId(tab.id);\n    }, [setCurrentTabId]);\n\n    return useMemo(() => ({\n        tabs: memoizedTabs,\n        handleTabChange,\n        ...products,\n    }), [memoizedTabs, handleTabChange, products]);\n}\n\nexport type ProductColumn = {\n    title: string;\n    source: DeferredDataSource<IProduct[]>;\n};\n\nexport function useProductColumns(columns: ProductColumn[]) {\n    const products = useDeferredData(() => (\n        Promise.all(columns.map((column) => column.source()))\n    ), [], undefined, [columns]);\n\n    return useMemo(() => (\n        columns.map((column, index) => ({\n            ...column,\n            products: products.data[index] || [],\n        }))\n    ), [columns, products]);\n}\n"]},"metadata":{},"sourceType":"module"}