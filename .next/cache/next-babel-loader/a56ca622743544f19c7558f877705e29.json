{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport AbstractFilterBuilder from './abstract';\nimport productsData from '../database/products';\nexport default class RadioFilterBuilder extends AbstractFilterBuilder {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"items\", []);\n\n    _defineProperty(this, \"value\", null);\n  }\n\n  test(product) {\n    return this.value !== null && this.extractItems(product).map(x => x.slug).includes(this.value);\n  }\n\n  makeItems(products, value) {\n    products.forEach(product => this.extractItems(product).forEach(item => {\n      if (!this.items.find(x => x.slug === item.slug)) {\n        this.items.push(item);\n      }\n    }));\n    this.value = value || this.items[0].slug;\n  }\n\n  calc(filters) {\n    const products = productsData.filter(product => filters.reduce((isMatched, filter) => isMatched && (filter === this || filter.test(product)), true));\n    this.items = this.items.map(item => {\n      const count = products.reduce((acc, product) => {\n        const match = this.extractItems(product).map(x => x.slug).includes(item.slug);\n        return acc + (match ? 1 : 0);\n      }, 0);\n      return _objectSpread(_objectSpread({}, item), {}, {\n        count\n      });\n    });\n  }\n\n  build() {\n    return {\n      type: 'radio',\n      slug: this.slug,\n      name: this.name,\n      items: this.items,\n      value: this.value\n    };\n  }\n\n  extractItems(product) {\n    if (this.slug === 'discount') {\n      const items = [{\n        slug: 'any',\n        name: 'Any',\n        count: 0\n      }];\n\n      if (product.compareAtPrice) {\n        items.push({\n          slug: 'yes',\n          name: 'Yes',\n          count: 0\n        });\n      } else {\n        items.push({\n          slug: 'no',\n          name: 'No',\n          count: 0\n        });\n      }\n\n      return items;\n    }\n\n    throw Error();\n  }\n\n}","map":{"version":3,"sources":["D:/xampp/htdocs/neo.co.th/nextapp/src/fake-server/filters/radio.ts"],"names":["AbstractFilterBuilder","productsData","RadioFilterBuilder","test","product","value","extractItems","map","x","slug","includes","makeItems","products","forEach","item","items","find","push","calc","filters","filter","reduce","isMatched","count","acc","match","build","type","name","compareAtPrice","Error"],"mappings":"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","sourcesContent":["import AbstractFilterBuilder from './abstract';\nimport productsData from '../database/products';\nimport { IBaseFilterItem, IRadioFilter, IRadioFilterValue } from '../../interfaces/filter';\nimport { IProduct } from '../../interfaces/product';\n\nexport default class RadioFilterBuilder extends AbstractFilterBuilder {\n    items: IBaseFilterItem[] = [];\n\n    value: IRadioFilterValue = null;\n\n    test(product: IProduct): boolean {\n        return this.value !== null && this.extractItems(product).map((x) => x.slug).includes(this.value);\n    }\n\n    makeItems(products: IProduct[], value?: string): void {\n        products.forEach((product) => this.extractItems(product).forEach((item) => {\n            if (!this.items.find((x) => x.slug === item.slug)) {\n                this.items.push(item);\n            }\n        }));\n\n        this.value = value || this.items[0].slug;\n    }\n\n    calc(filters: AbstractFilterBuilder[]): void {\n        const products = productsData.filter(\n            (product) => filters.reduce<boolean>(\n                (isMatched, filter) => isMatched && (filter === this || filter.test(product)),\n                true,\n            ),\n        );\n\n        this.items = this.items.map((item) => {\n            const count = products.reduce((acc, product) => {\n                const match = this.extractItems(product).map((x) => x.slug).includes(item.slug);\n\n                return acc + (match ? 1 : 0);\n            }, 0);\n\n            return { ...item, count };\n        });\n    }\n\n    build(): IRadioFilter {\n        return {\n            type: 'radio',\n            slug: this.slug,\n            name: this.name,\n            items: this.items,\n            value: this.value,\n        };\n    }\n\n    extractItems(product: IProduct): IBaseFilterItem[] {\n        if (this.slug === 'discount') {\n            const items = [\n                { slug: 'any', name: 'Any', count: 0 },\n            ];\n\n            if (product.compareAtPrice) {\n                items.push({ slug: 'yes', name: 'Yes', count: 0 });\n            } else {\n                items.push({ slug: 'no', name: 'No', count: 0 });\n            }\n\n            return items;\n        }\n\n        throw Error();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}