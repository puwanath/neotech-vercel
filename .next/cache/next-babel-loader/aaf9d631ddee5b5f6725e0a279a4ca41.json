{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport AbstractFilterBuilder from './abstract';\nimport productsData from '../database/products';\n\nfunction parseValue(value) {\n  return value ? value.split(',') : [];\n}\n\nexport default class CheckFilterBuilder extends AbstractFilterBuilder {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"items\", []);\n\n    _defineProperty(this, \"value\", []);\n  }\n\n  test(product) {\n    if (this.value.length === 0) {\n      return true;\n    }\n\n    return this.value.reduce((result, value) => result || this.extractItems(product).map(x => x.slug).includes(value), false);\n  }\n\n  makeItems(products, value) {\n    products.forEach(product => this.extractItems(product).forEach(item => {\n      if (!this.items.find(x => x.slug === item.slug)) {\n        this.items.push(item);\n      }\n    }));\n    this.value = parseValue(value);\n  }\n\n  calc(filters) {\n    const products = productsData.filter(product => filters.reduce((isMatched, filter) => isMatched && (filter === this || filter.test(product)), true));\n    this.items = this.items.map(item => {\n      const count = products.reduce((acc, product) => acc + (this.extractItems(product).map(x => x.slug).includes(item.slug) ? 1 : 0), 0);\n      return _objectSpread(_objectSpread({}, item), {}, {\n        count\n      });\n    });\n  }\n\n  build() {\n    return {\n      type: 'check',\n      slug: this.slug,\n      name: this.name,\n      items: this.items,\n      value: this.value\n    };\n  }\n\n  extractItems(product) {\n    if (this.slug === 'brand') {\n      return product.brand ? [{\n        slug: product.brand.slug,\n        name: product.brand.name,\n        count: 0\n      }] : [];\n    }\n\n    throw Error();\n  }\n\n}","map":{"version":3,"sources":["D:/xampp/htdocs/neo.co.th/nextapp/src/fake-server/filters/check.ts"],"names":["AbstractFilterBuilder","productsData","parseValue","value","split","CheckFilterBuilder","test","product","length","reduce","result","extractItems","map","x","slug","includes","makeItems","products","forEach","item","items","find","push","calc","filters","filter","isMatched","count","acc","build","type","name","brand","Error"],"mappings":"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","sourcesContent":["import AbstractFilterBuilder from './abstract';\nimport productsData from '../database/products';\nimport { IBaseFilterItem, ICheckFilter, ICheckFilterValue } from '../../interfaces/filter';\nimport { IProduct } from '../../interfaces/product';\n\nfunction parseValue(value?: string): string[] {\n    return value ? value.split(',') : [];\n}\n\nexport default class CheckFilterBuilder extends AbstractFilterBuilder<ICheckFilter> {\n    items: IBaseFilterItem[] = [];\n\n    value: ICheckFilterValue = [];\n\n    test(product: IProduct): boolean {\n        if (this.value.length === 0) {\n            return true;\n        }\n\n        return this.value.reduce<boolean>((result, value) => (\n            result || this.extractItems(product).map((x) => x.slug).includes(value)\n        ), false);\n    }\n\n    makeItems(products: IProduct[], value?: string) {\n        products.forEach((product) => this.extractItems(product).forEach((item) => {\n            if (!this.items.find((x) => x.slug === item.slug)) {\n                this.items.push(item);\n            }\n        }));\n\n        this.value = parseValue(value);\n    }\n\n    calc(filters: AbstractFilterBuilder[]): void {\n        const products = productsData.filter(\n            (product) => filters.reduce<boolean>(\n                (isMatched, filter) => (\n                    isMatched && (filter === this || filter.test(product))\n                ),\n                true,\n            ),\n        );\n\n        this.items = this.items.map((item) => {\n            const count = products.reduce((acc, product) => (\n                acc + (this.extractItems(product).map((x) => x.slug).includes(item.slug) ? 1 : 0)\n            ), 0);\n\n            return { ...item, count };\n        });\n    }\n\n    build(): ICheckFilter {\n        return {\n            type: 'check',\n            slug: this.slug,\n            name: this.name,\n            items: this.items,\n            value: this.value,\n        };\n    }\n\n    extractItems(product: IProduct): IBaseFilterItem[] {\n        if (this.slug === 'brand') {\n            return product.brand ? [{\n                slug: product.brand.slug,\n                name: product.brand.name,\n                count: 0,\n            }] : [];\n        }\n\n        throw Error();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}